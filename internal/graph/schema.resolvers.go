package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.58

import (
	"context"
	"database/sql"
	"errors"
	"fmt"
	"log"
	"strconv"
	"time"
)

// CreatePost is the resolver for the createPost field.
func (r *mutationResolver) CreatePost(ctx context.Context, title string, content string) (*Post, error) {
	var post Post
	var createdAt time.Time

	err := r.DB.QueryRow(
		`INSERT INTO posts (title, content)
   VALUES ($1, $2)
   RETURNING id, title, content, comments_enabled, created_at`,
		title, content,
	).Scan(&post.ID, &post.Title, &post.Content, &post.CommentsEnabled, &createdAt)
	if err != nil {
		log.Printf("Ошибка при создании поста: %v", err)
		return nil, fmt.Errorf("не удалось создать пост")
	}

	// Преобразуем createdAt в строку
	post.CreatedAt = createdAt.Format(time.RFC3339)

	return &post, nil
}

// CreateComment is the resolver for the createComment field.
func (r *mutationResolver) CreateComment(ctx context.Context, postID string, text string) (*Comment, error) {
	var comment Comment
	var commentsEnabled bool

	err := r.DB.QueryRow("SELECT comments_enabled FROM posts WHERE id = $1", postID).Scan(&commentsEnabled)
	if err != nil {
		return nil, err
	}

	if !commentsEnabled {
		return nil, fmt.Errorf("комментарии отключены для этого поста")
	}

	err = r.DB.QueryRow(
		"INSERT INTO comments (post_id, text) VALUES ($1, $2) RETURNING id, post_id, text, created_at",
		postID, text,
	).Scan(&comment.ID, &comment.PostID, &comment.Text, &comment.CreatedAt)
	if err != nil {
		return nil, err
	}

	return &comment, nil
}

// ToggleComments is the resolver for the toggleComments field.
func (r *mutationResolver) ToggleComments(ctx context.Context, postID string, enabled bool) (*Post, error) {
	var post Post
	err := r.DB.QueryRow(
		"UPDATE posts SET comments_enabled = $1 WHERE id = $2 RETURNING id, title, content, comments_enabled, created_at",
		enabled, postID,
	).Scan(&post.ID, &post.Title, &post.Content, &post.CommentsEnabled, &post.CreatedAt)
	if err != nil {
		return nil, err
	}

	return &post, nil
}

// Posts is the resolver for the posts field.
func (r *queryResolver) Posts(ctx context.Context) ([]*Post, error) {

	rows, err := r.DB.Query("SELECT id, title, content, comments_enabled, created_at FROM posts")
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var posts []*Post
	for rows.Next() {
		var post Post
		if err := rows.Scan(&post.ID, &post.Title, &post.Content, &post.CommentsEnabled, &post.CreatedAt); err != nil {
			log.Printf("Ошибка при обработке строки: %v", err)
			return nil, err
		}

		postId, _ := strconv.Atoi(post.ID)
		comments, err := r.getCommentsForPost(postId)
		if err != nil {
			return nil, err
		}

		post.Comments = comments
		posts = append(posts, &post)
	}

	return posts, nil

}

// Post is the resolver for the post field.
func (r *queryResolver) Post(ctx context.Context, id string) (*Post, error) {
	// Преобразуем id из string в int
	postID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("неверный формат ID: %v", err)
	}

	var post Post
	var createdAt time.Time

	// Выполняем запрос к базе данных
	err = r.DB.QueryRow(
		`SELECT id, title, content, comments_enabled, created_at 
   FROM posts WHERE id = $1`,
		postID,
	).Scan(&post.ID, &post.Title, &post.Content, &post.CommentsEnabled, &createdAt)
	if err != nil {
		if errors.Is(err, sql.ErrNoRows) {
			return nil, fmt.Errorf("пост с ID %d не найден", postID)
		}
		log.Printf("Ошибка при получении поста: %v", err)
		return nil, err
	}

	post.CreatedAt = createdAt.Format(time.RFC3339)

	// Получаем комментарии
	comments, err := r.getCommentsForPost(postID)
	if err != nil {
		log.Printf("Ошибка при получении комментариев: %v", err)
		return nil, err
	}
	post.Comments = comments

	return &post, nil
}

// Вспомогательная функция для получения комментариев к посту
func (r *queryResolver) getCommentsForPost(postID int) ([]*Comment, error) {
	rows, err := r.DB.Query(
		`SELECT id, post_id, text, created_at 
   FROM comments WHERE post_id = $1`,
		postID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	var comments []*Comment
	for rows.Next() {
		var comment Comment
		var createdAt time.Time
		if err := rows.Scan(&comment.ID, &comment.PostID, &comment.Text, &createdAt); err != nil {
			return nil, err
		}
		comment.CreatedAt = createdAt.Format(time.RFC3339)
		comments = append(comments, &comment) // Добавляем указатель на comment
	}

	return comments, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
